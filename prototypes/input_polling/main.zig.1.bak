const std = @import("std");
const assert = std.debug.assert;

pub const PollerEnum = enum { file, otherFile };
pub const ReadStatus = union(enum) { StreamClosed: void, TimedOut: void, ReadLen: usize };

pub fn read(poller: *std.io.Poller(PollerEnum)) !ReadStatus {
    const timeout_ns = std.time.ns_per_ms;
    const should_keep_polling = try poller.pollTimeout(timeout_ns);

    var total_len_read: usize = 0;

    inline for (comptime std.meta.tags(PollerEnum)) |file| {
        const fifo = poller.fifo(file);
        const len = fifo.readableLength();

        if (len != 0) {
            total_len_read += len;

            const slice = fifo.readableSlice(0);
            assert(slice.len == len);

            std.debug.print("key pressed: {s}\n", .{slice});

            fifo.discard(len);
        }
    }

    if (total_len_read == 0 and !should_keep_polling) return .StreamClosed;
    if (total_len_read == 0) return .TimedOut;

    return .{ .ReadLen = total_len_read };
}

pub fn init_poller(alloc: std.mem.Allocator) std.io.Poller(PollerEnum) {
    return std.io.poll(alloc, PollerEnum, .{
        .file = std.io.getStdIn(),
        .otherFile = std.io.getStdOut(),
    });
}

pub fn main() !void {
    var poller = init_poller(std.heap.page_allocator);

    while (true) {
        switch (try read(&poller)) {
            .StreamClosed => break,
            else => {},
        }
    }
}
